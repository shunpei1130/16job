<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>就活キャラ診断（Apple風）</title>
  <style>
    :root{
      --bg:#f5f5f7;
      --card:#ffffff;
      --text:#1d1d1f;
      --muted:#6e6e73;
      --line:#e5e5ea;
      --primary:#0a84ff;
      --primary-dark:#0071e3;
      --danger:#ff3b30;
      --shadow: 0 12px 40px rgba(0,0,0,.08);
      --radius: 22px;
      --radius-sm: 16px;
      --max: 980px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic",sans-serif;
      line-height:1.5;
    }
    header{
      position:sticky;
      top:0;
      z-index:10;
      backdrop-filter: blur(18px);
      background: rgba(245,245,247,.72);
      border-bottom: 1px solid rgba(0,0,0,.06);
    }
    .wrap{
      max-width: var(--max);
      margin: 0 auto;
      padding: 14px 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:14px;
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight:700;
      letter-spacing:.2px;
    }
    .dot{
      width:10px;height:10px;border-radius:99px;
      background: linear-gradient(135deg, #0a84ff, #34c759);
      box-shadow: 0 6px 16px rgba(10,132,255,.25);
    }
    .ghost{
      border:1px solid rgba(0,0,0,.10);
      background: rgba(255,255,255,.70);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 14px;
      cursor:pointer;
      font-weight:600;
    }
    .ghost:active{ transform: translateY(1px); }
    main{
      max-width: var(--max);
      margin: 0 auto;
      padding: 26px 18px 70px;
    }
    .card{
      background:var(--card);
      border: 1px solid rgba(0,0,0,.06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 24px;
    }
    .hero{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: 24px;
      align-items:center;
    }
    @media (max-width: 860px){
      .hero{ grid-template-columns: 1fr; }
    }
    .kicker{
      color: var(--muted);
      font-weight:600;
      font-size: 13px;
      letter-spacing:.2px;
      margin:0 0 8px;
    }
    h1{
      margin:0;
      font-size: 34px;
      line-height:1.2;
      letter-spacing: -0.4px;
    }
    .lead{
      margin: 12px 0 18px;
      color: var(--muted);
      font-size: 15px;
    }
    .cta{
      display:flex;
      gap: 12px;
      align-items:center;
      flex-wrap:wrap;
      margin-top: 10px;
    }
    button.primary{
      background: linear-gradient(180deg, var(--primary), var(--primary-dark));
      color: #fff;
      border: 0;
      padding: 12px 16px;
      border-radius: 14px;
      font-weight: 700;
      cursor:pointer;
      box-shadow: 0 14px 30px rgba(10,132,255,.25);
    }
    button.primary:disabled{
      opacity:.55;
      cursor:not-allowed;
      box-shadow:none;
    }
    button.primary:active{ transform: translateY(1px); }
    .note{
      font-size: 12px;
      color: var(--muted);
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-top: 16px;
    }
    @media (max-width: 740px){
      .grid2{ grid-template-columns: 1fr; }
    }
    .mini{
      border: 1px solid rgba(0,0,0,.06);
      background: rgba(245,245,247,.55);
      border-radius: var(--radius-sm);
      padding: 16px;
    }
    .mini .t{
      font-weight:700;
      margin:0 0 6px;
    }
    .mini .d{
      margin:0;
      color: var(--muted);
      font-size: 13px;
    }
    .progress-wrap{
      margin-bottom: 18px;
    }
    .progress-head{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:12px;
      margin-bottom: 10px;
    }
    .title{
      font-size: 20px;
      font-weight: 800;
      letter-spacing:-0.2px;
      margin:0;
    }
    .muted{ color: var(--muted); }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(10,132,255,.08);
      border: 1px solid rgba(10,132,255,.18);
      color: #0a84ff;
      font-weight: 700;
      font-size: 12px;
    }
    .progress-track{
      width:100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.06);
      overflow:hidden;
    }
    .progress-fill{
      height:100%;
      border-radius: 999px;
      background: linear-gradient(90deg, #0a84ff, #34c759);
      width:0%;
      transition: width .25s ease;
    }
    .qCard{
      border: 1px solid rgba(0,0,0,.06);
      border-radius: var(--radius-sm);
      padding: 18px;
      background: #fff;
      margin-bottom: 14px;
    }
    .qHead{
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:flex-start;
      margin-bottom: 12px;
    }
    .qTitle{
      margin:0;
      font-weight:800;
      letter-spacing:-0.2px;
    }
    .qSub{
      margin:4px 0 0;
      color: var(--muted);
      font-size: 12px;
    }

    /* Likert (7 options) */
    .likert{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-start;
    }
    .likert-btn{
      border: 1px solid rgba(0,0,0,.10);
      background: rgba(245,245,247,.70);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor:pointer;
      font-weight:700;
      font-size: 13px;
      min-width: 92px;
      text-align:center;
      transition: transform .06s ease, box-shadow .2s ease, border-color .2s ease;
      user-select:none;
    }
    .likert-btn:active{ transform: translateY(1px); }
    .likert-btn.selected{
      border-color: rgba(10,132,255,.55);
      box-shadow: 0 10px 22px rgba(10,132,255,.18);
      background: rgba(10,132,255,.10);
      color:#0a84ff;
    }
    @media (max-width: 540px){
      /* スマホは縦並び */
      .likert{
        flex-direction: column;
        gap: 10px;
      }
      .likert-btn{
        width:100%;
        min-width: unset;
        padding: 14px 14px;
        font-size: 14px;
        border-radius: 16px;
        text-align:left;
      }
    }

    .actionsRow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      margin-top: 18px;
    }
    .actionsRow button{
      flex: 1;
    }
    .actionsRow button:first-child{
      flex: 0 0 auto;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,.10);
      background: rgba(245,245,247,.70);
      font-weight:700;
      cursor:pointer;
      color: var(--text);
    }
    .actionsRow button:disabled{
      opacity:.45;
      cursor:not-allowed;
    }

    /* Result */
    .resultTop{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      align-items:stretch;
    }
    @media (max-width: 860px){
      .resultTop{ grid-template-columns:1fr; }
    }
    .avatar{
      width: 100%;
      min-height: 220px;
      border-radius: var(--radius);
      border: 1px solid rgba(0,0,0,.06);
      background:
        radial-gradient(1200px 300px at 0% 0%, rgba(10,132,255,.12), transparent 60%),
        radial-gradient(800px 240px at 100% 0%, rgba(52,199,89,.10), transparent 55%),
        linear-gradient(180deg, rgba(245,245,247,.60), rgba(255,255,255,1));
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 16px;
      position:relative;
      overflow:hidden;
    }
    .avatar img{
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: calc(var(--radius) - 8px);
      border: 1px solid rgba(0,0,0,.06);
      background:#fff;
    }
    .avatar .placeholder{
      color: var(--muted);
      font-weight:700;
      text-align:center;
      padding: 18px;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px solid rgba(0,0,0,.08);
      background: rgba(255,255,255,.75);
      font-weight: 800;
      letter-spacing:-0.2px;
      margin-bottom: 8px;
    }
    .resultName{
      font-size: 28px;
      margin: 6px 0 10px;
      letter-spacing: -0.4px;
      font-weight: 900;
    }
    .resultDesc{
      margin: 0 0 10px;
      color: var(--muted);
    }
    .section{
      margin-top: 18px;
      border-top: 1px solid rgba(0,0,0,.06);
      padding-top: 16px;
    }
    .section h3{
      margin:0 0 8px;
      font-size: 16px;
      letter-spacing:-0.2px;
    }
    .bullets{
      margin: 0;
      padding-left: 18px;
      color: var(--text);
    }
    .bullets li{
      margin: 6px 0;
    }
    .axisGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    @media (max-width: 700px){
      .axisGrid{ grid-template-columns: 1fr; }
    }
    .axisCard{
      border: 1px solid rgba(0,0,0,.06);
      background: rgba(245,245,247,.55);
      border-radius: var(--radius-sm);
      padding: 14px;
    }
    .axisTop{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      margin-bottom: 8px;
    }
    .axisLabel{
      font-weight:800;
      letter-spacing:-0.2px;
    }
    .bar{
      width:100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.06);
      overflow:hidden;
    }
    .bar > div{
      height:100%;
      border-radius: 999px;
      background: linear-gradient(90deg, #0a84ff, #34c759);
      width: 50%;
    }
    .small{
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
    }
    .error{
      color: var(--danger);
      font-weight: 700;
      font-size: 13px;
      margin-top: 10px;
    }

    .fade-in{
      animation: fadeIn .25s ease both;
    }
    @keyframes fadeIn{
      from{ opacity:0; transform: translateY(8px); }
      to{ opacity:1; transform: translateY(0); }
    }

    /* ---- Gate (registration) ---- */
    .form{ margin-top: 18px; }
    .field{ display:flex; flex-direction:column; gap:6px; margin-top:12px; }
    .label{ font-size:12px; color: var(--muted); }
    .input{
      width:100%;
      padding: 14px 14px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: #fff;
      font-size: 14px;
      outline: none;
    }
    .input:focus{
      border-color: rgba(0,0,0,.25);
      box-shadow: 0 0 0 4px rgba(0,0,0,.06);
    }
    .actions{ display:flex; gap:10px; margin-top:18px; justify-content:space-between; }
    .actions button{ flex:1; }
    .actions button#btnGateBack{ flex:0 0 auto; }
    .consent{
      display:flex;
      gap:10px;
      align-items:flex-start;
      margin-top: 14px;
      font-size:12px;
      color: var(--muted);
      user-select:none;
    }
  </style>
</head>

<body>
  <header>
    <div class="wrap">
      <div class="brand"><span class="dot"></span> 就活キャラ診断</div>
      <button class="ghost" id="btnReset">リセット</button>
    </div>
  </header>

  <main>
    <div id="app"></div>
  </main>

  <script>
    /***********************
     * Data
     ***********************/
    const QUESTIONS = [
      // --- A軸：安定/仕組み重視（L） vs 変化/勢い重視（R）
      { id:"Q1", axis:"A", reverse:false, text:"長期的に安定している環境の方が落ち着く", sub:"安定/仕組みを重視する傾向" },
      { id:"Q2", axis:"A", reverse:false, text:"予定やルールが明確だと安心して動ける", sub:"仕組みで成果を出す" },
      { id:"Q3", axis:"A", reverse:false, text:"大きな賭けよりも確実性を優先したい", sub:"堅実さを重視" },
      { id:"Q4", axis:"A", reverse:true,  text:"変化が激しいほど燃える", sub:"勢い/変化への耐性" },
      { id:"Q5", axis:"A", reverse:true,  text:"多少の混乱があっても前に進める方が大事", sub:"スピード優先" },

      // --- B軸：チーム協調（L） vs 個人裁量（R）
      { id:"Q6", axis:"B", reverse:false, text:"周りと足並みを揃えることが成果につながると思う", sub:"協調性" },
      { id:"Q7", axis:"B", reverse:false, text:"チーム内の空気を読みながら動くのが得意だ", sub:"調整力" },
      { id:"Q8", axis:"B", reverse:false, text:"自分の主張よりも全体最適を優先しがちだ", sub:"合意形成" },
      { id:"Q9", axis:"B", reverse:true,  text:"自分のやり方で進められる方が力を発揮できる", sub:"裁量志向" },
      { id:"Q10", axis:"B", reverse:true, text:"人に合わせるより、最短で結果を出すことを優先したい", sub:"独走力" },

      // --- C軸：コツコツ（L） vs ド派手（R）
      { id:"Q11", axis:"C", reverse:false, text:"地味でも積み上げ続けるのは得意な方だ", sub:"継続力" },
      { id:"Q12", axis:"C", reverse:false, text:"小さな改善を積み重ねて成果を出したい", sub:"改善志向" },
      { id:"Q13", axis:"C", reverse:false, text:"派手さよりも再現性のある努力を評価したい", sub:"安定実行" },
      { id:"Q14", axis:"C", reverse:true,  text:"目立つ成果を一発で出したいと思う", sub:"インパクト志向" },
      { id:"Q15", axis:"C", reverse:true,  text:"人前に立つほどテンションが上がる", sub:"表舞台志向" },

      // --- D軸：論理（L） vs 感情（R）
      { id:"Q16", axis:"D", reverse:false, text:"意思決定はまず根拠やデータから考える", sub:"論理優先" },
      { id:"Q17", axis:"D", reverse:false, text:"感情よりも合理性を優先して判断しがちだ", sub:"合理性" },
      { id:"Q18", axis:"D", reverse:false, text:"冷静に状況を整理するのが得意だ", sub:"分析力" },
      { id:"Q19", axis:"D", reverse:true,  text:"直感で決めた方がうまくいくことが多い", sub:"直感" },
      { id:"Q20", axis:"D", reverse:true,  text:"相手の気持ちに強く共感して動くことが多い", sub:"共感" },

      // 40問に合わせて追加（簡易に同系統で拡張）
      { id:"Q21", axis:"A", reverse:false, text:"計画を立ててから動く方が安心する", sub:"計画性" },
      { id:"Q22", axis:"A", reverse:true,  text:"予定変更が多い方がワクワクする", sub:"変化耐性" },
      { id:"Q23", axis:"B", reverse:false, text:"周囲の意見を取り入れて決めることが多い", sub:"協調" },
      { id:"Q24", axis:"B", reverse:true,  text:"自分の判断で即決したい", sub:"即断" },
      { id:"Q25", axis:"C", reverse:false, text:"毎日少しずつでも進める方が得意だ", sub:"積み上げ" },
      { id:"Q26", axis:"C", reverse:true,  text:"ここぞの勝負で勝つ方が好きだ", sub:"勝負勘" },
      { id:"Q27", axis:"D", reverse:false, text:"結論を出す前に条件を整理したい", sub:"整理" },
      { id:"Q28", axis:"D", reverse:true,  text:"人の感情が場を動かすと思う", sub:"情緒" },

      { id:"Q29", axis:"A", reverse:false, text:"リスクを洗い出してから進めたい", sub:"リスク管理" },
      { id:"Q30", axis:"A", reverse:true,  text:"多少無理でも早く試したい", sub:"トライ" },
      { id:"Q31", axis:"B", reverse:false, text:"和を乱さないように立ち回る", sub:"調和" },
      { id:"Q32", axis:"B", reverse:true,  text:"遠慮せず意見を通す方だ", sub:"主張" },
      { id:"Q33", axis:"C", reverse:false, text:"ルーティンを作ると強い", sub:"習慣" },
      { id:"Q34", axis:"C", reverse:true,  text:"注目される場で結果を出したい", sub:"注目" },
      { id:"Q35", axis:"D", reverse:false, text:"感情に流されるのは避けたい", sub:"冷静" },
      { id:"Q36", axis:"D", reverse:true,  text:"気持ちが乗れば一気に動ける", sub:"感情ドライブ" },

      { id:"Q37", axis:"A", reverse:false, text:"一貫した手順がある方が安心する", sub:"手順" },
      { id:"Q38", axis:"B", reverse:true,  text:"一人で完結させる仕事が好きだ", sub:"単独" },
      { id:"Q39", axis:"C", reverse:false, text:"派手さより着実さを選ぶ", sub:"着実" },
      { id:"Q40", axis:"D", reverse:true,  text:"相手の気分を最優先して動くことがある", sub:"配慮" },
    ];

    // 結果キャラ（画像URLはあとで差し替えOK）
    const CHARACTERS = {
      "LLLL": { name:"安定の番人", img:"", desc:"仕組みで勝つ堅実派。安心できる土台を作るのが得意。", bullets:["手順化・標準化が得意","一貫性が高い","信頼を積む"]},
      "LLLR": { name:"調整の参謀", img:"", desc:"安定基盤×共感で周りを支える参謀タイプ。", bullets:["関係調整が上手い","相談役になりがち","縁の下で効く"]},
      "LLRL": { name:"職人ストラテジスト", img:"", desc:"積み上げ×論理で成果を出す職人。", bullets:["改善が止まらない","品質に強い","分析で伸びる"]},
      "LLRR": { name:"柔らかい設計者", img:"", desc:"仕組み×共感のバランス型。", bullets:["気遣いと構造化の両立","現場を整える","安心感がある"]},

      "LRLL": { name:"堅実リーダー", img:"", desc:"個の裁量を持ちつつ堅実に積むリーダー。", bullets:["自走できる","堅実に成果","責任感"]},
      "LRLR": { name:"一匹狼の支援者", img:"", desc:"裁量×共感で人を救う一匹狼。", bullets:["単独で動ける","必要な人に刺さる","優しさが武器"]},
      "LRRL": { name:"孤高の職人", img:"", desc:"裁量×積み上げ×論理で勝つ。", bullets:["黙々と強い","判断が速い","無駄がない"]},
      "LRRR": { name:"直感アーティスト", img:"", desc:"裁量×派手×共感で魅せる。", bullets:["表現力が強い","盛り上げ上手","波に乗ると最強"]},

      "RLLL": { name:"変化対応の調整屋", img:"", desc:"変化に強く、協調もできる万能タイプ。", bullets:["適応が速い","関係構築が上手","場を前に進める"]},
      "RLLR": { name:"ムードメーカー", img:"", desc:"変化×協調×共感で場を温める。", bullets:["雰囲気を作る","巻き込みが得意","人の感情に強い"]},
      "RLRL": { name:"スピード職人", img:"", desc:"変化×裁量×論理で高速に作る。", bullets:["試して学ぶ","決断が速い","実装力"]},
      "RLRR": { name:"勢いのプロデューサー", img:"", desc:"変化×裁量×共感で人を動かす。", bullets:["巻き込み力","挑戦が好き","熱量が伝染する"]},

      "RRLL": { name:"派手好きの堅実派", img:"", desc:"インパクトを狙いつつ土台も作る。", bullets:["見せ方が上手い","成果にこだわる","バランス感"]},
      "RRLR": { name:"スターサポーター", img:"", desc:"目立ちつつ人も大事にする。", bullets:["発信が強い","共感を集める","場を照らす"]},
      "RRRL": { name:"勝負師アナリスト", img:"", desc:"派手に勝ちつつ、頭も回る勝負師。", bullets:["勝負所が分かる","ロジカルに攻める","成果が派手"]},
      "RRRR": { name:"無双のカリスマ", img:"", desc:"どんな状況でも瞬時に最適解を出し、周りを驚かせる。", bullets:["爆発力","巻き込み力","スケールする"]},
    };

    const STORAGE_KEY = "shukatsu_diag_apple_v1";
    const PAGE_SIZE = 5; // 40問 ÷ 5問 = 8ページ

    const state = {
      step: "intro", // intro | quiz | gate | result
      page: 0,
      answers: {},
      profile: { name: "", email: "" },
    };

    /***********************
     * Functions
     ***********************/
    function loadState(){
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if(raw) Object.assign(state, JSON.parse(raw));
      } catch(e){}
    }
    function saveState(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }
    function resetState(){
      state.step = "intro";
      state.page = 0;
      state.answers = {};
      state.profile = { name: "", email: "" };
      localStorage.removeItem(STORAGE_KEY);
      render();
    }

    function computeResult(){
      // 7択: 1..7（左=そう思う(強) 〜 右=そう思わない(強)）
      // スコアリング方針:
      // - 端の回答(1/7)は「確信が強い」とみなし、重みを上げる
      // - 非線形変換で中間(3/5)の影響を圧縮し、端が相対的に効きやすくする
      // - reverse:true（右側を肯定する文）は (8-ans) で反転し、「左寄り=プラス」に統一
      // - 軸内で回答が割れている（相殺）場合は、過剰に断定しないよう少しだけ中立へ寄せる
      const SCALE = 7;
      const MID = 4;          // 中央
      const MAX_DEV = 3;      // MIDからの最大偏差（1 or 7）
      const GAMMA = 1.35;     // 非線形：大きいほど中間が弱まり、端が相対的に強くなる
      const EXTREME_BONUS = 0.35; // 端(1/7)の重み +35%
      const COHERENCE_SHRINK = 0.20; // 相殺が強い軸は最大20%だけ中立へ寄せる

      const raw = {A:0, B:0, C:0, D:0};        // 左(+)/右(-)
      const absRaw = {A:0, B:0, C:0, D:0};     // 絶対値（相殺の計算）
      const maxRaw = {A:0, B:0, C:0, D:0};     // 正規化用
      const coherenceByAxis = {A:0, B:0, C:0, D:0};

      QUESTIONS.forEach(q => {
        const ans = state.answers[q.id];
        if(!ans) return;

        // reverseなら反転して「左寄りがプラス」に統一
        const v = q.reverse ? (8 - ans) : ans;

        // MIDを0にする偏差（-3..+3）
        const dev = v - MID;

        // 正規化（-1..+1）
        const norm = dev / MAX_DEV;

        // 非線形（符号維持）
        const sgn = norm === 0 ? 0 : (norm > 0 ? 1 : -1);
        let mag = Math.pow(Math.abs(norm), GAMMA);

        // 端ならボーナス
        if(v === 1 || v === 7) mag *= (1 + EXTREME_BONUS);

        const score = sgn * mag;

        raw[q.axis] += score;
        absRaw[q.axis] += Math.abs(score);

        // 最大値（理論上の最大を積む）
        // 1問の最大magは 1^GAMMA * (1+bonus) = (1+bonus)
        maxRaw[q.axis] += (1 + EXTREME_BONUS);
      });

      // coherence: 相殺の少なさ（= |raw| / absRaw）
      ["A","B","C","D"].forEach(ax=>{
        const denom = absRaw[ax] || 1e-9;
        const coh = Math.min(1, Math.abs(raw[ax]) / denom);
        coherenceByAxis[ax] = coh;

        // 相殺が強い軸ほど中立へ少し寄せる（rawを縮める）
        const shrink = 1 - (1 - coh) * COHERENCE_SHRINK;
        raw[ax] *= shrink;
      });

      // 正規化して -1..+1 へ
      const normAxis = {};
      ["A","B","C","D"].forEach(ax=>{
        const denom = maxRaw[ax] || 1e-9;
        normAxis[ax] = Math.max(-1, Math.min(1, raw[ax] / denom));
      });

      // hard判定（L/R）
      const hard = {};
      ["A","B","C","D"].forEach(ax=>{
        hard[ax] = normAxis[ax] >= 0 ? "L" : "R";
      });
      const code = hard.A + hard.B + hard.C + hard.D;

      // 表示用：左(%)（0..100）
      const leftPct = {};
      ["A","B","C","D"].forEach(ax=>{
        leftPct[ax] = Math.round((normAxis[ax] + 1) * 50);
      });

      // 決断度（全軸の|norm|平均）
      const decisiveness = (Math.abs(normAxis.A)+Math.abs(normAxis.B)+Math.abs(normAxis.C)+Math.abs(normAxis.D))/4;

      // 直線性（相殺が少ないほど高い）
      const straightLine = (coherenceByAxis.A + coherenceByAxis.B + coherenceByAxis.C + coherenceByAxis.D)/4;

      // breakdown（デバッグ用だが画面には出さない）
      const breakdown = {
        raw, normAxis, coherenceByAxis,
        decisiveness: Math.round(decisiveness*100),
        straightLine: Math.round(straightLine*100),
      };

      return { hard, code, norm: normAxis, leftPct, coherenceByAxis, breakdown, decisiveness, straightLine, char: CHARACTERS[code] };
    }

    // --- Rendering ---
    const app = document.getElementById("app");
    document.getElementById("btnReset").onclick = () => {
      if(confirm("最初からやり直しますか？")) resetState();
    };

    function render(){
      window.scrollTo(0,0);
      if(state.step === "intro") renderIntro();
      else if(state.step === "quiz") renderQuiz();
      else if(state.step === "gate") renderGate();
      else renderResult();
    }

    function renderIntro(){
      const answered = Object.keys(state.answers).length;
      const progress = Math.round((answered / QUESTIONS.length) * 100);

      app.innerHTML = `
        <div class="card hero fade-in">
          <div>
            <p class="kicker">就活版MBTI / キャラ診断</p>
            <h1>あなたの「就活キャラ」を1分で可視化</h1>
            <p class="lead">
              40問の直感回答で、ES・面接で刺さる自己理解の“型”を作ります。<br>
              迷いやすい就活生向けに、優しく・シンプルに。
            </p>
            <div class="cta">
              <button class="primary" id="btnStart">${answered ? "続きから再開" : "診断をはじめる"}</button>
              <span class="note">所要時間：約3〜5分 / 40問</span>
            </div>

            <div class="grid2">
              <div class="mini">
                <p class="t">出るもの</p>
                <p class="d">あなたのキャラ名＋ES/面接の話し方の指針</p>
              </div>
              <div class="mini">
                <p class="t">安心設計</p>
                <p class="d">UIはApple風にシンプル / スマホ最適化</p>
              </div>
            </div>
          </div>
          <div>
            <div class="progress-wrap">
              <div class="progress-head">
                <div>
                  <div class="pill">進捗</div>
                  <div class="title">診断の進み具合</div>
                </div>
                <div class="muted">${progress}%</div>
              </div>
              <div class="progress-track">
                <div class="progress-fill" style="width:${progress}%"></div>
              </div>
            </div>

            <div class="mini">
              <p class="t" style="margin:0 0 8px;">回答のコツ</p>
              <p class="d" style="margin:0;">深く考えすぎず、今の自分に近いものを選んでください。</p>
            </div>
          </div>
        </div>
      `;

      document.getElementById("btnStart").onclick = () => {
        state.step = "quiz";
        saveState();
        render();
      };
    }

    function renderQuiz(){
      const totalPage = Math.ceil(QUESTIONS.length / PAGE_SIZE);
      const start = state.page * PAGE_SIZE;
      const currentQs = QUESTIONS.slice(start, start + PAGE_SIZE);

      const answered = Object.keys(state.answers).length;
      const progress = Math.round((answered / QUESTIONS.length) * 100);

      const qHtml = currentQs.map(q => {
        const selected = state.answers[q.id] || null;

        const options = [
          {v:1, t:"強くそう思う"},
          {v:2, t:"そう思う"},
          {v:3, t:"ややそう思う"},
          {v:4, t:"どちらでもない"},
          {v:5, t:"ややそう思わない"},
          {v:6, t:"そう思わない"},
          {v:7, t:"強くそう思わない"},
        ];

        return `
          <div class="qCard">
            <div class="qHead">
              <div>
                <div class="qTitle">${q.text}</div>
                <div class="qSub">${q.sub}</div>
              </div>
              <div class="muted" style="font-weight:800;">${q.id}</div>
            </div>
            <div class="likert">
              ${options.map(o=>{
                const cls = (selected === o.v) ? "likert-btn selected" : "likert-btn";
                return `<button type="button" class="${cls}" data-qid="${q.id}" data-val="${o.v}">${o.t}</button>`;
              }).join("")}
            </div>
          </div>
        `;
      }).join("");

      app.innerHTML = `
        <div class="card fade-in">
          <div class="progress-wrap">
            <div class="progress-head">
              <div>
                <div class="pill">質問 ${state.page+1}/${totalPage}</div>
                <div class="title">直感で選んでください</div>
              </div>
              <div class="muted">${progress}%</div>
            </div>
            <div class="progress-track">
              <div class="progress-fill" style="width:${progress}%"></div>
            </div>
          </div>

          <div style="margin-top:30px;">
            ${qHtml}
          </div>

          <div class="actionsRow">
            <button id="btnPrev" ${state.page===0 ? "disabled":""}>戻る</button>
            <button class="primary" id="btnNext">
              ${state.page === totalPage - 1 ? "結果を見る" : "次へ"}
            </button>
          </div>
        </div>
      `;

      // Event Listeners
      currentQs.forEach(q => {
        document.querySelectorAll(`button.likert-btn[data-qid="${q.id}"]`).forEach(btn => {
          btn.onclick = () => {
            const val = parseInt(btn.dataset.val);
            state.answers[q.id] = val;

            // 選択状態の見た目更新
            document.querySelectorAll(`button.likert-btn[data-qid="${q.id}"]`).forEach(b => b.classList.remove("selected"));
            btn.classList.add("selected");

            saveState();

            // プログレスバーだけ更新
            const p = Math.round((Object.keys(state.answers).length / QUESTIONS.length) * 100);
            const fill = document.querySelector(".progress-fill");
            const per = document.querySelector(".progress-head .muted");
            if(fill) fill.style.width = p + "%";
            if(per) per.textContent = p + "%";
          };
        });
      });

      document.getElementById("btnPrev").onclick = () => {
        state.page--;
        saveState();
        render();
      };

      document.getElementById("btnNext").onclick = () => {
        // Validation
        const missing = currentQs.find(q => !state.answers[q.id]);
        if(missing){
          alert("まだ回答していない項目があります");
          return;
        }
        if(state.page < totalPage - 1){
          state.page++;
          saveState();
          render();
        } else {
          const alreadyRegistered = !!(state.profile && state.profile.email);
          state.step = alreadyRegistered ? "result" : "gate";
          saveState();
          render();
        }
      };
    }

    async function submitLead(payload){
      const r = await fetch("/api/lead", {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify(payload)
      });
      const data = await r.json().catch(()=> ({}));
      if(!r.ok) throw new Error(data?.error || "送信に失敗しました");
      return data;
    }

    function renderGate(){
      const res = computeResult(); // ここで計算（表示はまだしない）
      const progress = Math.round((Object.keys(state.answers).length / QUESTIONS.length) * 100);

      app.innerHTML = `
        <div class="card fade-in">
          <div class="progress-wrap" style="margin-bottom:18px;">
            <div class="progress-head">
              <div>
                <div class="pill">登録</div>
                <div class="title">結果の閲覧には登録が必要です</div>
              </div>
              <div class="muted">${progress}%</div>
            </div>
            <div class="progress-track">
              <div class="progress-fill" style="width:${progress}%"></div>
            </div>
          </div>

          <div class="muted" style="margin-top:-2px;">
            入力後すぐに診断結果を表示します。
          </div>

          <div class="form" style="margin-top:18px;">
            <div class="field">
              <label class="label">お名前</label>
              <input id="regName" class="input" type="text" placeholder="例）山田 太郎">
            </div>

            <div class="field">
              <label class="label">メールアドレス</label>
              <input id="regEmail" class="input" type="email" placeholder="example@gmail.com">
            </div>

            <label class="consent">
              <input id="regConsent" type="checkbox">
              <span>入力した情報を連絡・改善のために保存することに同意します。</span>
            </label>

            <div id="regErr" class="error" style="display:none;"></div>

            <div class="actions">
              <button id="btnGateBack">戻る</button>
              <button class="primary" id="btnGateGo">結果を見る</button>
            </div>

            <div class="muted" style="margin-top:10px; font-size:12px;">
              送信される内容：名前、メール、診断TYPE（${res.code}）、各軸の比率（A〜D）
            </div>
          </div>
        </div>
      `;

      // 既存値を反映
      const nameEl = document.getElementById("regName");
      const emailEl = document.getElementById("regEmail");
      nameEl.value = state.profile?.name || "";
      emailEl.value = state.profile?.email || "";

      document.getElementById("btnGateBack").onclick = () => {
        state.step = "quiz";
        saveState();
        render();
      };

      document.getElementById("btnGateGo").onclick = async () => {
        const errEl = document.getElementById("regErr");
        errEl.style.display = "none";
        errEl.textContent = "";

        const name = (nameEl.value || "").trim();
        const email = (emailEl.value || "").trim();
        const consent = document.getElementById("regConsent").checked;

        const emailOk = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

        if(!name){ errEl.textContent = "名前を入力してください"; errEl.style.display="block"; return; }
        if(!emailOk){ errEl.textContent = "メールアドレスを正しく入力してください"; errEl.style.display="block"; return; }
        if(!consent){ errEl.textContent = "同意にチェックしてください"; errEl.style.display="block"; return; }

        const btn = document.getElementById("btnGateGo");
        btn.disabled = true;
        btn.textContent = "送信中…";

        try{
          const payload = {
            name,
            email,
            type: res.code,
            axes: res.leftPct,
            createdAt: new Date().toISOString(),
            meta: {
              hard: res.hard,
              norm: res.norm
            }
          };

          await submitLead(payload);

          state.profile = { name, email };
          state.step = "result";
          saveState();
          render();
        }catch(e){
          errEl.textContent = e?.message || "送信に失敗しました";
          errEl.style.display="block";
          btn.disabled = false;
          btn.textContent = "結果を見る";
        }
      };
    }

    function renderResult(){
      const res = computeResult();
      const char = res.char;

      // ES・面接アドバイスの生成（簡易）
      const isL = (k) => res.hard[k] === "L";
      const esTip = isL("C")
        ? ["結論→根拠→再現性の順で書く", "努力のプロセスを数字で示す", "改善ループ（課題→仮説→実行→検証）を入れる"]
        : ["成果のインパクトを先に出す", "勝負所での決断を物語にする", "巻き込みと推進の具体例を書く"];

      const interviewTip = isL("D")
        ? ["質問意図を整理してから答える", "根拠・比較・トレードオフを言語化", "再現性のある強みとして語る"]
        : ["感情の動き（なぜ熱中したか）を語る", "人への影響を具体化する", "熱量→行動→結果の順で伝える"];

      const axisNames = {
        A: ["安定・仕組み", "変化・勢い"],
        B: ["協調・チーム", "裁量・個人"],
        C: ["コツコツ", "ド派手"],
        D: ["論理", "感情"],
      };

      const axisHtml = ["A","B","C","D"].map(ax=>{
        const left = res.leftPct[ax];
        const right = 100 - left;
        const leftName = axisNames[ax][0];
        const rightName = axisNames[ax][1];

        return `
          <div class="axisCard">
            <div class="axisTop">
              <div class="axisLabel">${leftName} ↔ ${rightName}</div>
              <div class="muted" style="font-weight:800;">${left}%</div>
            </div>
            <div class="bar"><div style="width:${left}%;"></div></div>
            <div class="small">${leftName} ${left}% / ${rightName} ${right}%</div>
          </div>
        `;
      }).join("");

      const imgHtml = char?.img
        ? `<img src="${char.img}" alt="${char.name}">`
        : `<div class="placeholder">（ここにキャラ画像が入ります）<br>後で画像URLを差し替えてください</div>`;

      app.innerHTML = `
        <div class="card fade-in">
          <div class="resultTop">
            <div class="avatar">${imgHtml}</div>
            <div>
              <div class="badge">あなたの就活キャラ</div>
              <div class="resultName">${char?.name || "診断結果"}</div>
              <p class="resultDesc">${char?.desc || ""}</p>

              <div class="section">
                <h3>キャラ特徴</h3>
                <ul class="bullets">
                  ${(char?.bullets || []).map(x=>`<li>${x}</li>`).join("")}
                </ul>
              </div>

              <div class="section">
                <h3>あなたの傾向（4軸）</h3>
                <div class="axisGrid">${axisHtml}</div>
              </div>
            </div>
          </div>

          <div class="section">
            <h3>ESで刺さる書き方</h3>
            <ul class="bullets">${esTip.map(x=>`<li>${x}</li>`).join("")}</ul>
          </div>

          <div class="section">
            <h3>面接で刺さる話し方</h3>
            <ul class="bullets">${interviewTip.map(x=>`<li>${x}</li>`).join("")}</ul>
          </div>

          <div class="section">
            <div class="actionsRow">
              <button id="btnBackToTop">トップへ</button>
              <button class="primary" id="btnRetry">もう一度やる</button>
            </div>
            <div class="small">※ 登録情報は端末に保存されるため、次回は登録をスキップします（同じ端末/ブラウザの場合）。</div>
          </div>
        </div>
      `;

      document.getElementById("btnBackToTop").onclick = () => {
        state.step = "intro";
        saveState();
        render();
      };
      document.getElementById("btnRetry").onclick = () => {
        if(confirm("回答をクリアして最初からやり直しますか？")){
          resetState();
        }
      };
    }

    // init
    loadState();
    render();
  </script>
</body>
</html>
